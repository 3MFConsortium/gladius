/*++

Copyright (C) 2023 Jan Orend

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of GladiusLib. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.2.0

*/

#include "gladius_abi.hpp"
#include "gladius_interfaces.hpp"
#include "gladius_interfaceexception.hpp"

#include <map>

using namespace GladiusLib::Impl;

GladiusLibResult handleGladiusLibException(IBase * pIBaseClass, EGladiusLibInterfaceException & Exception)
{
    GladiusLibResult errorCode = Exception.getErrorCode();

    if (pIBaseClass != nullptr)
        pIBaseClass->RegisterErrorMessage(Exception.what());

    return errorCode;
}

GladiusLibResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
    GladiusLibResult errorCode = GLADIUSLIB_ERROR_GENERICEXCEPTION;

    if (pIBaseClass != nullptr)
        pIBaseClass->RegisterErrorMessage(Exception.what());

    return errorCode;
}

GladiusLibResult handleUnhandledException(IBase * pIBaseClass)
{
    GladiusLibResult errorCode = GLADIUSLIB_ERROR_GENERICEXCEPTION;

    if (pIBaseClass != nullptr)
        pIBaseClass->RegisterErrorMessage("Unhandled Exception");

    return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for BoundingBox
**************************************************************************************************************************/
GladiusLibResult gladiuslib_boundingbox_getmin(GladiusLib_BoundingBox pBoundingBox, sGladiusLibVector3f * pMin)
{
    IBase* pIBaseClass = (IBase *)pBoundingBox;

    try {
        if (pMin == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBoundingBox* pIBoundingBox = dynamic_cast<IBoundingBox*>(pIBaseClass);
        if (!pIBoundingBox)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pMin = pIBoundingBox->GetMin();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_boundingbox_getmax(GladiusLib_BoundingBox pBoundingBox, sGladiusLibVector3f * pMax)
{
    IBase* pIBaseClass = (IBase *)pBoundingBox;

    try {
        if (pMax == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBoundingBox* pIBoundingBox = dynamic_cast<IBoundingBox*>(pIBaseClass);
        if (!pIBoundingBox)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pMax = pIBoundingBox->GetMax();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for Face
**************************************************************************************************************************/
GladiusLibResult gladiuslib_face_getvertexa(GladiusLib_Face pFace, sGladiusLibVector3f * pVertexA)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pVertexA == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pVertexA = pIFace->GetVertexA();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getvertexb(GladiusLib_Face pFace, sGladiusLibVector3f * pVertexB)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pVertexB == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pVertexB = pIFace->GetVertexB();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getvertexc(GladiusLib_Face pFace, sGladiusLibVector3f * pVertexC)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pVertexC == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pVertexC = pIFace->GetVertexC();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getnormal(GladiusLib_Face pFace, sGladiusLibVector3f * pNormal)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pNormal == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pNormal = pIFace->GetNormal();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getnormala(GladiusLib_Face pFace, sGladiusLibVector3f * pNormal)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pNormal == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pNormal = pIFace->GetNormalA();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getnormalb(GladiusLib_Face pFace, sGladiusLibVector3f * pNormal)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pNormal == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pNormal = pIFace->GetNormalB();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_face_getnormalc(GladiusLib_Face pFace, sGladiusLibVector3f * pNormal)
{
    IBase* pIBaseClass = (IBase *)pFace;

    try {
        if (pNormal == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IFace* pIFace = dynamic_cast<IFace*>(pIBaseClass);
        if (!pIFace)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pNormal = pIFace->GetNormalC();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for DetailedErrorAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_detailederroraccessor_getsize(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, GladiusLib_uint64 * pSize)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if (pSize == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pSize = pIDetailedErrorAccessor->GetSize();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_next(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, bool * pResult)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if (pResult == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pResult = pIDetailedErrorAccessor->Next();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_prev(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, bool * pResult)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if (pResult == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pResult = pIDetailedErrorAccessor->Prev();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_begin(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIDetailedErrorAccessor->Begin();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_gettitle(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, const GladiusLib_uint32 nTitleBufferSize, GladiusLib_uint32* pTitleNeededChars, char * pTitleBuffer)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if ( (!pTitleBuffer) && !(pTitleNeededChars) )
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sTitle("");
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        sTitle = pIDetailedErrorAccessor->GetTitle();

        if (pTitleNeededChars)
            *pTitleNeededChars = (GladiusLib_uint32) (sTitle.size()+1);
        if (pTitleBuffer) {
            if (sTitle.size() >= nTitleBufferSize)
                throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_BUFFERTOOSMALL);
            for (size_t iTitle = 0; iTitle < sTitle.size(); iTitle++)
                pTitleBuffer[iTitle] = sTitle[iTitle];
            pTitleBuffer[sTitle.size()] = 0;
        }
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_getdescription(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, const GladiusLib_uint32 nDescriptionBufferSize, GladiusLib_uint32* pDescriptionNeededChars, char * pDescriptionBuffer)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sDescription("");
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        sDescription = pIDetailedErrorAccessor->GetDescription();

        if (pDescriptionNeededChars)
            *pDescriptionNeededChars = (GladiusLib_uint32) (sDescription.size()+1);
        if (pDescriptionBuffer) {
            if (sDescription.size() >= nDescriptionBufferSize)
                throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_BUFFERTOOSMALL);
            for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
                pDescriptionBuffer[iDescription] = sDescription[iDescription];
            pDescriptionBuffer[sDescription.size()] = 0;
        }
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_detailederroraccessor_getseverity(GladiusLib_DetailedErrorAccessor pDetailedErrorAccessor, GladiusLib_uint32 * pSeverity)
{
    IBase* pIBaseClass = (IBase *)pDetailedErrorAccessor;

    try {
        if (pSeverity == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IDetailedErrorAccessor* pIDetailedErrorAccessor = dynamic_cast<IDetailedErrorAccessor*>(pIBaseClass);
        if (!pIDetailedErrorAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pSeverity = pIDetailedErrorAccessor->GetSeverity();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for ResourceAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_resourceaccessor_getsize(GladiusLib_ResourceAccessor pResourceAccessor, GladiusLib_uint64 * pSize)
{
    IBase* pIBaseClass = (IBase *)pResourceAccessor;

    try {
        if (pSize == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IResourceAccessor* pIResourceAccessor = dynamic_cast<IResourceAccessor*>(pIBaseClass);
        if (!pIResourceAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pSize = pIResourceAccessor->GetSize();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_resourceaccessor_next(GladiusLib_ResourceAccessor pResourceAccessor, bool * pResult)
{
    IBase* pIBaseClass = (IBase *)pResourceAccessor;

    try {
        if (pResult == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IResourceAccessor* pIResourceAccessor = dynamic_cast<IResourceAccessor*>(pIBaseClass);
        if (!pIResourceAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pResult = pIResourceAccessor->Next();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_resourceaccessor_prev(GladiusLib_ResourceAccessor pResourceAccessor, bool * pResult)
{
    IBase* pIBaseClass = (IBase *)pResourceAccessor;

    try {
        if (pResult == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IResourceAccessor* pIResourceAccessor = dynamic_cast<IResourceAccessor*>(pIBaseClass);
        if (!pIResourceAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pResult = pIResourceAccessor->Prev();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_resourceaccessor_begin(GladiusLib_ResourceAccessor pResourceAccessor)
{
    IBase* pIBaseClass = (IBase *)pResourceAccessor;

    try {
        IResourceAccessor* pIResourceAccessor = dynamic_cast<IResourceAccessor*>(pIBaseClass);
        if (!pIResourceAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIResourceAccessor->Begin();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for PolygonAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_polygonaccessor_getcurrentvertex(GladiusLib_PolygonAccessor pPolygonAccessor, sGladiusLibVector2f * pVertex)
{
    IBase* pIBaseClass = (IBase *)pPolygonAccessor;

    try {
        if (pVertex == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IPolygonAccessor* pIPolygonAccessor = dynamic_cast<IPolygonAccessor*>(pIBaseClass);
        if (!pIPolygonAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pVertex = pIPolygonAccessor->GetCurrentVertex();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_polygonaccessor_getarea(GladiusLib_PolygonAccessor pPolygonAccessor, GladiusLib_single * pArea)
{
    IBase* pIBaseClass = (IBase *)pPolygonAccessor;

    try {
        if (pArea == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IPolygonAccessor* pIPolygonAccessor = dynamic_cast<IPolygonAccessor*>(pIBaseClass);
        if (!pIPolygonAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pArea = pIPolygonAccessor->GetArea();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for ContourAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_contouraccessor_getcurrentpolygon(GladiusLib_ContourAccessor pContourAccessor, GladiusLib_PolygonAccessor * pVertex)
{
    IBase* pIBaseClass = (IBase *)pContourAccessor;

    try {
        if (pVertex == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseVertex(nullptr);
        IContourAccessor* pIContourAccessor = dynamic_cast<IContourAccessor*>(pIBaseClass);
        if (!pIContourAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseVertex = pIContourAccessor->GetCurrentPolygon();

        *pVertex = (IBase*)(pBaseVertex);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for FaceAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_faceaccessor_getcurrentface(GladiusLib_FaceAccessor pFaceAccessor, GladiusLib_Face * pFace)
{
    IBase* pIBaseClass = (IBase *)pFaceAccessor;

    try {
        if (pFace == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseFace(nullptr);
        IFaceAccessor* pIFaceAccessor = dynamic_cast<IFaceAccessor*>(pIBaseClass);
        if (!pIFaceAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseFace = pIFaceAccessor->GetCurrentFace();

        *pFace = (IBase*)(pBaseFace);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for ChannelAccessor
**************************************************************************************************************************/
GladiusLibResult gladiuslib_channelaccessor_evaluate(GladiusLib_ChannelAccessor pChannelAccessor, GladiusLib_single fZ_mm, GladiusLib_single fPixelWidth_mm, GladiusLib_single fPixelHeight_mm)
{
    IBase* pIBaseClass = (IBase *)pChannelAccessor;

    try {
        IChannelAccessor* pIChannelAccessor = dynamic_cast<IChannelAccessor*>(pIBaseClass);
        if (!pIChannelAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIChannelAccessor->Evaluate(fZ_mm, fPixelWidth_mm, fPixelHeight_mm);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_channelaccessor_getmetainfo(GladiusLib_ChannelAccessor pChannelAccessor, sGladiusLibChannelMetaInfo * pMetaInfo)
{
    IBase* pIBaseClass = (IBase *)pChannelAccessor;

    try {
        if (pMetaInfo == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IChannelAccessor* pIChannelAccessor = dynamic_cast<IChannelAccessor*>(pIBaseClass);
        if (!pIChannelAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pMetaInfo = pIChannelAccessor->GetMetaInfo();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_channelaccessor_copy(GladiusLib_ChannelAccessor pChannelAccessor, GladiusLib_int64 nTargetPtr)
{
    IBase* pIBaseClass = (IBase *)pChannelAccessor;

    try {
        IChannelAccessor* pIChannelAccessor = dynamic_cast<IChannelAccessor*>(pIBaseClass);
        if (!pIChannelAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIChannelAccessor->Copy(nTargetPtr);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_channelaccessor_getname(GladiusLib_ChannelAccessor pChannelAccessor, const GladiusLib_uint32 nNameBufferSize, GladiusLib_uint32* pNameNeededChars, char * pNameBuffer)
{
    IBase* pIBaseClass = (IBase *)pChannelAccessor;

    try {
        if ( (!pNameBuffer) && !(pNameNeededChars) )
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sName("");
        IChannelAccessor* pIChannelAccessor = dynamic_cast<IChannelAccessor*>(pIBaseClass);
        if (!pIChannelAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        sName = pIChannelAccessor->GetName();

        if (pNameNeededChars)
            *pNameNeededChars = (GladiusLib_uint32) (sName.size()+1);
        if (pNameBuffer) {
            if (sName.size() >= nNameBufferSize)
                throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_BUFFERTOOSMALL);
            for (size_t iName = 0; iName < sName.size(); iName++)
                pNameBuffer[iName] = sName[iName];
            pNameBuffer[sName.size()] = 0;
        }
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_channelaccessor_switchtochannel(GladiusLib_ChannelAccessor pChannelAccessor, const char * pName, bool * pResult)
{
    IBase* pIBaseClass = (IBase *)pChannelAccessor;

    try {
        if (pName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pResult == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sName(pName);
        IChannelAccessor* pIChannelAccessor = dynamic_cast<IChannelAccessor*>(pIBaseClass);
        if (!pIChannelAccessor)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pResult = pIChannelAccessor->SwitchToChannel(sName);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}


/*************************************************************************************************************************
 Class implementation for Gladius
**************************************************************************************************************************/
GladiusLibResult gladiuslib_gladius_loadassembly(GladiusLib_Gladius pGladius, const char * pFilename)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pFilename == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sFilename(pFilename);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->LoadAssembly(sFilename);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_exportstl(GladiusLib_Gladius pGladius, const char * pFilename)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pFilename == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sFilename(pFilename);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->ExportSTL(sFilename);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_getfloatparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, GladiusLib_single * pValue)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pValue == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pValue = pIGladius->GetFloatParameter(sModelName, sNodeName, sParameterName);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_setfloatparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, GladiusLib_single fValue)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->SetFloatParameter(sModelName, sNodeName, sParameterName, fValue);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_getstringparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, const GladiusLib_uint32 nValueBufferSize, GladiusLib_uint32* pValueNeededChars, char * pValueBuffer)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if ( (!pValueBuffer) && !(pValueNeededChars) )
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        std::string sValue("");
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        sValue = pIGladius->GetStringParameter(sModelName, sNodeName, sParameterName);

        if (pValueNeededChars)
            *pValueNeededChars = (GladiusLib_uint32) (sValue.size()+1);
        if (pValueBuffer) {
            if (sValue.size() >= nValueBufferSize)
                throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_BUFFERTOOSMALL);
            for (size_t iValue = 0; iValue < sValue.size(); iValue++)
                pValueBuffer[iValue] = sValue[iValue];
            pValueBuffer[sValue.size()] = 0;
        }
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_setstringparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, const char * pValue)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pValue == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        std::string sValue(pValue);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->SetStringParameter(sModelName, sNodeName, sParameterName, sValue);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_getvector3fparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, sGladiusLibVector3f * pValue)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pValue == nullptr)
        throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        *pValue = pIGladius->GetVector3fParameter(sModelName, sNodeName, sParameterName);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_setvector3fparameter(GladiusLib_Gladius pGladius, const char * pModelName, const char * pNodeName, const char * pParameterName, GladiusLib_single fX, GladiusLib_single fY, GladiusLib_single fZ)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pModelName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pNodeName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pParameterName == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sModelName(pModelName);
        std::string sNodeName(pNodeName);
        std::string sParameterName(pParameterName);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->SetVector3fParameter(sModelName, sNodeName, sParameterName, fX, fY, fZ);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_generatecontour(GladiusLib_Gladius pGladius, GladiusLib_single fZ, GladiusLib_single fOffset, GladiusLib_ContourAccessor * pAccessor)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pAccessor == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseAccessor(nullptr);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseAccessor = pIGladius->GenerateContour(fZ, fOffset);

        *pAccessor = (IBase*)(pBaseAccessor);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_computeboundingbox(GladiusLib_Gladius pGladius, GladiusLib_BoundingBox * pBoundingBox)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pBoundingBox == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseBoundingBox(nullptr);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseBoundingBox = pIGladius->ComputeBoundingBox();

        *pBoundingBox = (IBase*)(pBaseBoundingBox);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_generatepreviewmesh(GladiusLib_Gladius pGladius, GladiusLib_FaceAccessor * pFaces)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pFaces == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseFaces(nullptr);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseFaces = pIGladius->GeneratePreviewMesh();

        *pFaces = (IBase*)(pBaseFaces);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_getchannels(GladiusLib_Gladius pGladius, GladiusLib_ChannelAccessor * pAccessor)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pAccessor == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseAccessor(nullptr);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseAccessor = pIGladius->GetChannels();

        *pAccessor = (IBase*)(pBaseAccessor);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_getdetailederroraccessor(GladiusLib_Gladius pGladius, GladiusLib_DetailedErrorAccessor * pAccessor)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pAccessor == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseAccessor(nullptr);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pBaseAccessor = pIGladius->GetDetailedErrorAccessor();

        *pAccessor = (IBase*)(pBaseAccessor);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_cleardetailederrors(GladiusLib_Gladius pGladius)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->ClearDetailedErrors();

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_gladius_injectsmoothingkernel(GladiusLib_Gladius pGladius, const char * pKernel)
{
    IBase* pIBaseClass = (IBase *)pGladius;

    try {
        if (pKernel == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        std::string sKernel(pKernel);
        IGladius* pIGladius = dynamic_cast<IGladius*>(pIBaseClass);
        if (!pIGladius)
            throw EGladiusLibInterfaceException(GLADIUSLIB_ERROR_INVALIDCAST);
        
        pIGladius->InjectSmoothingKernel(sKernel);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

GladiusLibResult _gladiuslib_getprocaddress_internal(const char * pProcName, void ** ppProcAddress)
{
    static bool sbProcAddressMapHasBeenInitialized = false;
    static std::map<std::string, void*> sProcAddressMap;
    if (!sbProcAddressMapHasBeenInitialized) {
        sProcAddressMap["gladiuslib_boundingbox_getmin"] = (void*)&gladiuslib_boundingbox_getmin;
        sProcAddressMap["gladiuslib_boundingbox_getmax"] = (void*)&gladiuslib_boundingbox_getmax;
        sProcAddressMap["gladiuslib_face_getvertexa"] = (void*)&gladiuslib_face_getvertexa;
        sProcAddressMap["gladiuslib_face_getvertexb"] = (void*)&gladiuslib_face_getvertexb;
        sProcAddressMap["gladiuslib_face_getvertexc"] = (void*)&gladiuslib_face_getvertexc;
        sProcAddressMap["gladiuslib_face_getnormal"] = (void*)&gladiuslib_face_getnormal;
        sProcAddressMap["gladiuslib_face_getnormala"] = (void*)&gladiuslib_face_getnormala;
        sProcAddressMap["gladiuslib_face_getnormalb"] = (void*)&gladiuslib_face_getnormalb;
        sProcAddressMap["gladiuslib_face_getnormalc"] = (void*)&gladiuslib_face_getnormalc;
        sProcAddressMap["gladiuslib_detailederroraccessor_getsize"] = (void*)&gladiuslib_detailederroraccessor_getsize;
        sProcAddressMap["gladiuslib_detailederroraccessor_next"] = (void*)&gladiuslib_detailederroraccessor_next;
        sProcAddressMap["gladiuslib_detailederroraccessor_prev"] = (void*)&gladiuslib_detailederroraccessor_prev;
        sProcAddressMap["gladiuslib_detailederroraccessor_begin"] = (void*)&gladiuslib_detailederroraccessor_begin;
        sProcAddressMap["gladiuslib_detailederroraccessor_gettitle"] = (void*)&gladiuslib_detailederroraccessor_gettitle;
        sProcAddressMap["gladiuslib_detailederroraccessor_getdescription"] = (void*)&gladiuslib_detailederroraccessor_getdescription;
        sProcAddressMap["gladiuslib_detailederroraccessor_getseverity"] = (void*)&gladiuslib_detailederroraccessor_getseverity;
        sProcAddressMap["gladiuslib_resourceaccessor_getsize"] = (void*)&gladiuslib_resourceaccessor_getsize;
        sProcAddressMap["gladiuslib_resourceaccessor_next"] = (void*)&gladiuslib_resourceaccessor_next;
        sProcAddressMap["gladiuslib_resourceaccessor_prev"] = (void*)&gladiuslib_resourceaccessor_prev;
        sProcAddressMap["gladiuslib_resourceaccessor_begin"] = (void*)&gladiuslib_resourceaccessor_begin;
        sProcAddressMap["gladiuslib_polygonaccessor_getcurrentvertex"] = (void*)&gladiuslib_polygonaccessor_getcurrentvertex;
        sProcAddressMap["gladiuslib_polygonaccessor_getarea"] = (void*)&gladiuslib_polygonaccessor_getarea;
        sProcAddressMap["gladiuslib_contouraccessor_getcurrentpolygon"] = (void*)&gladiuslib_contouraccessor_getcurrentpolygon;
        sProcAddressMap["gladiuslib_faceaccessor_getcurrentface"] = (void*)&gladiuslib_faceaccessor_getcurrentface;
        sProcAddressMap["gladiuslib_channelaccessor_evaluate"] = (void*)&gladiuslib_channelaccessor_evaluate;
        sProcAddressMap["gladiuslib_channelaccessor_getmetainfo"] = (void*)&gladiuslib_channelaccessor_getmetainfo;
        sProcAddressMap["gladiuslib_channelaccessor_copy"] = (void*)&gladiuslib_channelaccessor_copy;
        sProcAddressMap["gladiuslib_channelaccessor_getname"] = (void*)&gladiuslib_channelaccessor_getname;
        sProcAddressMap["gladiuslib_channelaccessor_switchtochannel"] = (void*)&gladiuslib_channelaccessor_switchtochannel;
        sProcAddressMap["gladiuslib_gladius_loadassembly"] = (void*)&gladiuslib_gladius_loadassembly;
        sProcAddressMap["gladiuslib_gladius_exportstl"] = (void*)&gladiuslib_gladius_exportstl;
        sProcAddressMap["gladiuslib_gladius_getfloatparameter"] = (void*)&gladiuslib_gladius_getfloatparameter;
        sProcAddressMap["gladiuslib_gladius_setfloatparameter"] = (void*)&gladiuslib_gladius_setfloatparameter;
        sProcAddressMap["gladiuslib_gladius_getstringparameter"] = (void*)&gladiuslib_gladius_getstringparameter;
        sProcAddressMap["gladiuslib_gladius_setstringparameter"] = (void*)&gladiuslib_gladius_setstringparameter;
        sProcAddressMap["gladiuslib_gladius_getvector3fparameter"] = (void*)&gladiuslib_gladius_getvector3fparameter;
        sProcAddressMap["gladiuslib_gladius_setvector3fparameter"] = (void*)&gladiuslib_gladius_setvector3fparameter;
        sProcAddressMap["gladiuslib_gladius_generatecontour"] = (void*)&gladiuslib_gladius_generatecontour;
        sProcAddressMap["gladiuslib_gladius_computeboundingbox"] = (void*)&gladiuslib_gladius_computeboundingbox;
        sProcAddressMap["gladiuslib_gladius_generatepreviewmesh"] = (void*)&gladiuslib_gladius_generatepreviewmesh;
        sProcAddressMap["gladiuslib_gladius_getchannels"] = (void*)&gladiuslib_gladius_getchannels;
        sProcAddressMap["gladiuslib_gladius_getdetailederroraccessor"] = (void*)&gladiuslib_gladius_getdetailederroraccessor;
        sProcAddressMap["gladiuslib_gladius_cleardetailederrors"] = (void*)&gladiuslib_gladius_cleardetailederrors;
        sProcAddressMap["gladiuslib_gladius_injectsmoothingkernel"] = (void*)&gladiuslib_gladius_injectsmoothingkernel;
        sProcAddressMap["gladiuslib_getversion"] = (void*)&gladiuslib_getversion;
        sProcAddressMap["gladiuslib_getlasterror"] = (void*)&gladiuslib_getlasterror;
        sProcAddressMap["gladiuslib_acquireinstance"] = (void*)&gladiuslib_acquireinstance;
        sProcAddressMap["gladiuslib_releaseinstance"] = (void*)&gladiuslib_releaseinstance;
        sProcAddressMap["gladiuslib_creategladius"] = (void*)&gladiuslib_creategladius;
        
        sbProcAddressMapHasBeenInitialized = true;
    }
    if (pProcName == nullptr)
        return GLADIUSLIB_ERROR_INVALIDPARAM;
    if (ppProcAddress == nullptr)
        return GLADIUSLIB_ERROR_INVALIDPARAM;
    *ppProcAddress = nullptr;
    std::string sProcName (pProcName);
    
    auto procPair = sProcAddressMap.find(sProcName);
    if (procPair == sProcAddressMap.end()) {
        return GLADIUSLIB_ERROR_COULDNOTFINDLIBRARYEXPORT;
    }
    else {
        *ppProcAddress = procPair->second;
        return GLADIUSLIB_SUCCESS;
    }
    
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
GladiusLibResult gladiuslib_getversion(GladiusLib_uint32 * pMajor, GladiusLib_uint32 * pMinor, GladiusLib_uint32 * pMicro)
{
    IBase* pIBaseClass = nullptr;

    try {
        if (!pMajor)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (!pMinor)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (!pMicro)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_getlasterror(GladiusLib_Base pInstance, const GladiusLib_uint32 nErrorMessageBufferSize, GladiusLib_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
    IBase* pIBaseClass = nullptr;

    try {
        if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        if (pHasError == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pIBaseClassInstance = (IBase *)pInstance;
        IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
        if (!pIInstance)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDCAST);
        
        std::string sErrorMessage("");
        *pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

        if (pErrorMessageNeededChars)
            *pErrorMessageNeededChars = (GladiusLib_uint32) (sErrorMessage.size()+1);
        if (pErrorMessageBuffer) {
            if (sErrorMessage.size() >= nErrorMessageBufferSize)
                throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_BUFFERTOOSMALL);
            for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
                pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
            pErrorMessageBuffer[sErrorMessage.size()] = 0;
        }
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_acquireinstance(GladiusLib_Base pInstance)
{
    IBase* pIBaseClass = nullptr;

    try {
        IBase* pIBaseClassInstance = (IBase *)pInstance;
        IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
        if (!pIInstance)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDCAST);
        
        CWrapper::AcquireInstance(pIInstance);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_releaseinstance(GladiusLib_Base pInstance)
{
    IBase* pIBaseClass = nullptr;

    try {
        IBase* pIBaseClassInstance = (IBase *)pInstance;
        IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
        if (!pIInstance)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDCAST);
        
        CWrapper::ReleaseInstance(pIInstance);

        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}

GladiusLibResult gladiuslib_creategladius(GladiusLib_Gladius * pInstance)
{
    IBase* pIBaseClass = nullptr;

    try {
        if (pInstance == nullptr)
            throw EGladiusLibInterfaceException (GLADIUSLIB_ERROR_INVALIDPARAM);
        IBase* pBaseInstance(nullptr);
        pBaseInstance = CWrapper::CreateGladius();

        *pInstance = (IBase*)(pBaseInstance);
        return GLADIUSLIB_SUCCESS;
    }
    catch (EGladiusLibInterfaceException & Exception) {
        return handleGladiusLibException(pIBaseClass, Exception);
    }
    catch (std::exception & StdException) {
        return handleStdException(pIBaseClass, StdException);
    }
    catch (...) {
        return handleUnhandledException(pIBaseClass);
    }
}



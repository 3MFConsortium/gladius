/*++

Copyright (C) 2023 Jan Orend

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of GladiusLib

Interface version: 1.2.0

*/

#ifndef __GLADIUSLIB_CPPHEADER_IMPLICIT_CPP
#define __GLADIUSLIB_CPPHEADER_IMPLICIT_CPP

#include "gladius_types.hpp"
#include "gladius_abi.hpp"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace GladiusLib {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CBoundingBox;
class CFace;
class CDetailedErrorAccessor;
class CResourceAccessor;
class CPolygonAccessor;
class CContourAccessor;
class CFaceAccessor;
class CChannelAccessor;
class CGladius;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CGladiusLibWrapper;
typedef CBase CGladiusLibBase;
typedef CBoundingBox CGladiusLibBoundingBox;
typedef CFace CGladiusLibFace;
typedef CDetailedErrorAccessor CGladiusLibDetailedErrorAccessor;
typedef CResourceAccessor CGladiusLibResourceAccessor;
typedef CPolygonAccessor CGladiusLibPolygonAccessor;
typedef CContourAccessor CGladiusLibContourAccessor;
typedef CFaceAccessor CGladiusLibFaceAccessor;
typedef CChannelAccessor CGladiusLibChannelAccessor;
typedef CGladius CGladiusLibGladius;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CBoundingBox> PBoundingBox;
typedef std::shared_ptr<CFace> PFace;
typedef std::shared_ptr<CDetailedErrorAccessor> PDetailedErrorAccessor;
typedef std::shared_ptr<CResourceAccessor> PResourceAccessor;
typedef std::shared_ptr<CPolygonAccessor> PPolygonAccessor;
typedef std::shared_ptr<CContourAccessor> PContourAccessor;
typedef std::shared_ptr<CFaceAccessor> PFaceAccessor;
typedef std::shared_ptr<CChannelAccessor> PChannelAccessor;
typedef std::shared_ptr<CGladius> PGladius;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PGladiusLibWrapper;
typedef PBase PGladiusLibBase;
typedef PBoundingBox PGladiusLibBoundingBox;
typedef PFace PGladiusLibFace;
typedef PDetailedErrorAccessor PGladiusLibDetailedErrorAccessor;
typedef PResourceAccessor PGladiusLibResourceAccessor;
typedef PPolygonAccessor PGladiusLibPolygonAccessor;
typedef PContourAccessor PGladiusLibContourAccessor;
typedef PFaceAccessor PGladiusLibFaceAccessor;
typedef PChannelAccessor PGladiusLibChannelAccessor;
typedef PGladius PGladiusLibGladius;


/*************************************************************************************************************************
 Class EGladiusLibException 
**************************************************************************************************************************/
class EGladiusLibException : public std::exception {
protected:
    /**
    * Error code for the Exception.
    */
    GladiusLibResult m_errorCode;
    /**
    * Error message for the Exception.
    */
    std::string m_errorMessage;

public:
    /**
    * Exception Constructor.
    */
    EGladiusLibException(GladiusLibResult errorCode, const std::string & sErrorMessage)
        : m_errorMessage("GladiusLib Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
    {
        m_errorCode = errorCode;
    }

    /**
    * Returns error code
    */
    GladiusLibResult getErrorCode() const noexcept
    {
        return m_errorCode;
    }

    /**
    * Returns error message
    */
    const char* what() const noexcept
    {
        return m_errorMessage.c_str();
    }

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
    
    const T* m_data;
    size_t m_size;
    
public:
    
    CInputVector( const std::vector<T>& vec)
        : m_data( vec.data() ), m_size( vec.size() )
    {
    }
    
    CInputVector( const T* in_data, size_t in_size)
        : m_data( in_data ), m_size(in_size )
    {
    }
    
    const T* data() const
    {
        return m_data;
    }
    
    size_t size() const
    {
        return m_size;
    }
    
};

// declare deprecated class name
template<typename T>
using CGladiusLibInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
    
    CWrapper()
    {
    }
    
    ~CWrapper()
    {
    }
    static inline PWrapper loadLibrary()
    {
        return std::make_shared<CWrapper>();
    }
    
    inline void CheckError(CBase * pBaseClass, GladiusLibResult nResult);

    inline void GetVersion(GladiusLib_uint32 & nMajor, GladiusLib_uint32 & nMinor, GladiusLib_uint32 & nMicro);
    inline bool GetLastError(CBase * pInstance, std::string & sErrorMessage);
    inline void AcquireInstance(CBase * pInstance);
    inline void ReleaseInstance(CBase * pInstance);
    inline PGladius CreateGladius();

private:
    
    GladiusLibResult checkBinaryVersion()
    {
        GladiusLib_uint32 nMajor, nMinor, nMicro;
        GetVersion(nMajor, nMinor, nMicro);
        if ( (nMajor != GLADIUSLIB_VERSION_MAJOR) || (nMinor < GLADIUSLIB_VERSION_MINOR) ) {
            return GLADIUSLIB_ERROR_INCOMPATIBLEBINARYVERSION;
        }
        return GLADIUSLIB_SUCCESS;
    }

    friend class CBase;
    friend class CBoundingBox;
    friend class CFace;
    friend class CDetailedErrorAccessor;
    friend class CResourceAccessor;
    friend class CPolygonAccessor;
    friend class CContourAccessor;
    friend class CFaceAccessor;
    friend class CChannelAccessor;
    friend class CGladius;

};

    
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
    
protected:
    /* Wrapper Object that created the class. */
    CWrapper * m_pWrapper;
    /* Handle to Instance in library*/
    GladiusLibHandle m_pHandle;

    /* Checks for an Error code and raises Exceptions */
    void CheckError(GladiusLibResult nResult)
    {
        if (m_pWrapper != nullptr)
            m_pWrapper->CheckError(this, nResult);
    }
public:
    /**
    * CBase::CBase - Constructor for Base class.
    */
    CBase(CWrapper * pWrapper, GladiusLibHandle pHandle)
        : m_pWrapper(pWrapper), m_pHandle(pHandle)
    {
    }

    /**
    * CBase::~CBase - Destructor for Base class.
    */
    virtual ~CBase()
    {
        if (m_pWrapper != nullptr)
            m_pWrapper->ReleaseInstance(this);
        m_pWrapper = nullptr;
    }

    /**
    * CBase::GetHandle - Returns handle to instance.
    */
    GladiusLibHandle GetHandle()
    {
        return m_pHandle;
    }
    
    friend class CWrapper;
};
    
/*************************************************************************************************************************
 Class CBoundingBox 
**************************************************************************************************************************/
class CBoundingBox : public CBase {
public:
    
    /**
    * CBoundingBox::CBoundingBox - Constructor for BoundingBox class.
    */
    CBoundingBox(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CBase(pWrapper, pHandle)
    {
    }
    
    inline sVector3f GetMin();
    inline sVector3f GetMax();
};
    
/*************************************************************************************************************************
 Class CFace 
**************************************************************************************************************************/
class CFace : public CBase {
public:
    
    /**
    * CFace::CFace - Constructor for Face class.
    */
    CFace(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CBase(pWrapper, pHandle)
    {
    }
    
    inline sVector3f GetVertexA();
    inline sVector3f GetVertexB();
    inline sVector3f GetVertexC();
    inline sVector3f GetNormal();
    inline sVector3f GetNormalA();
    inline sVector3f GetNormalB();
    inline sVector3f GetNormalC();
};
    
/*************************************************************************************************************************
 Class CDetailedErrorAccessor 
**************************************************************************************************************************/
class CDetailedErrorAccessor : public CBase {
public:
    
    /**
    * CDetailedErrorAccessor::CDetailedErrorAccessor - Constructor for DetailedErrorAccessor class.
    */
    CDetailedErrorAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CBase(pWrapper, pHandle)
    {
    }
    
    inline GladiusLib_uint64 GetSize();
    inline bool Next();
    inline bool Prev();
    inline void Begin();
    inline std::string GetTitle();
    inline std::string GetDescription();
    inline GladiusLib_uint32 GetSeverity();
};
    
/*************************************************************************************************************************
 Class CResourceAccessor 
**************************************************************************************************************************/
class CResourceAccessor : public CBase {
public:
    
    /**
    * CResourceAccessor::CResourceAccessor - Constructor for ResourceAccessor class.
    */
    CResourceAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CBase(pWrapper, pHandle)
    {
    }
    
    inline GladiusLib_uint64 GetSize();
    inline bool Next();
    inline bool Prev();
    inline void Begin();
};
    
/*************************************************************************************************************************
 Class CPolygonAccessor 
**************************************************************************************************************************/
class CPolygonAccessor : public CResourceAccessor {
public:
    
    /**
    * CPolygonAccessor::CPolygonAccessor - Constructor for PolygonAccessor class.
    */
    CPolygonAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CResourceAccessor(pWrapper, pHandle)
    {
    }
    
    inline sVector2f GetCurrentVertex();
    inline GladiusLib_single GetArea();
};
    
/*************************************************************************************************************************
 Class CContourAccessor 
**************************************************************************************************************************/
class CContourAccessor : public CResourceAccessor {
public:
    
    /**
    * CContourAccessor::CContourAccessor - Constructor for ContourAccessor class.
    */
    CContourAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CResourceAccessor(pWrapper, pHandle)
    {
    }
    
    inline PPolygonAccessor GetCurrentPolygon();
};
    
/*************************************************************************************************************************
 Class CFaceAccessor 
**************************************************************************************************************************/
class CFaceAccessor : public CResourceAccessor {
public:
    
    /**
    * CFaceAccessor::CFaceAccessor - Constructor for FaceAccessor class.
    */
    CFaceAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CResourceAccessor(pWrapper, pHandle)
    {
    }
    
    inline PFace GetCurrentFace();
};
    
/*************************************************************************************************************************
 Class CChannelAccessor 
**************************************************************************************************************************/
class CChannelAccessor : public CResourceAccessor {
public:
    
    /**
    * CChannelAccessor::CChannelAccessor - Constructor for ChannelAccessor class.
    */
    CChannelAccessor(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CResourceAccessor(pWrapper, pHandle)
    {
    }
    
    inline void Evaluate(const GladiusLib_single fZ_mm, const GladiusLib_single fPixelWidth_mm, const GladiusLib_single fPixelHeight_mm);
    inline sChannelMetaInfo GetMetaInfo();
    inline void Copy(const GladiusLib_int64 nTargetPtr);
    inline std::string GetName();
    inline bool SwitchToChannel(const std::string & sName);
};
    
/*************************************************************************************************************************
 Class CGladius 
**************************************************************************************************************************/
class CGladius : public CBase {
public:
    
    /**
    * CGladius::CGladius - Constructor for Gladius class.
    */
    CGladius(CWrapper* pWrapper, GladiusLibHandle pHandle)
        : CBase(pWrapper, pHandle)
    {
    }
    
    inline void LoadAssembly(const std::string & sFilename);
    inline void ExportSTL(const std::string & sFilename);
    inline GladiusLib_single GetFloatParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName);
    inline void SetFloatParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const GladiusLib_single fValue);
    inline std::string GetStringParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName);
    inline void SetStringParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const std::string & sValue);
    inline sVector3f GetVector3fParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName);
    inline void SetVector3fParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const GladiusLib_single fX, const GladiusLib_single fY, const GladiusLib_single fZ);
    inline PContourAccessor GenerateContour(const GladiusLib_single fZ, const GladiusLib_single fOffset);
    inline PBoundingBox ComputeBoundingBox();
    inline PFaceAccessor GeneratePreviewMesh();
    inline PChannelAccessor GetChannels();
    inline PDetailedErrorAccessor GetDetailedErrorAccessor();
    inline void ClearDetailedErrors();
    inline void InjectSmoothingKernel(const std::string & sKernel);
};
    
    /**
    * CWrapper::GetVersion - retrieves the binary version of this library.
    * @param[out] nMajor - returns the major version of this library
    * @param[out] nMinor - returns the minor version of this library
    * @param[out] nMicro - returns the micro version of this library
    */
    inline void CWrapper::GetVersion(GladiusLib_uint32 & nMajor, GladiusLib_uint32 & nMinor, GladiusLib_uint32 & nMicro)
    {
        CheckError(nullptr,gladiuslib_getversion(&nMajor, &nMinor, &nMicro));
    }
    
    /**
    * CWrapper::GetLastError - Returns the last error recorded on this object
    * @param[in] pInstance - Instance Handle
    * @param[out] sErrorMessage - Message of the last error
    * @return Is there a last error to query
    */
    inline bool CWrapper::GetLastError(CBase * pInstance, std::string & sErrorMessage)
    {
        GladiusLibHandle hInstance = nullptr;
        if (pInstance != nullptr) {
            hInstance = pInstance->GetHandle();
        };
        GladiusLib_uint32 bytesNeededErrorMessage = 0;
        GladiusLib_uint32 bytesWrittenErrorMessage = 0;
        bool resultHasError = 0;
        CheckError(nullptr,gladiuslib_getlasterror(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
        std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
        CheckError(nullptr,gladiuslib_getlasterror(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
        sErrorMessage = std::string(&bufferErrorMessage[0]);
        
        return resultHasError;
    }
    
    /**
    * CWrapper::AcquireInstance - Acquire shared ownership of an Instance
    * @param[in] pInstance - Instance Handle
    */
    inline void CWrapper::AcquireInstance(CBase * pInstance)
    {
        GladiusLibHandle hInstance = nullptr;
        if (pInstance != nullptr) {
            hInstance = pInstance->GetHandle();
        };
        CheckError(nullptr,gladiuslib_acquireinstance(hInstance));
    }
    
    /**
    * CWrapper::ReleaseInstance - Releases shared ownership of an Instance
    * @param[in] pInstance - Instance Handle
    */
    inline void CWrapper::ReleaseInstance(CBase * pInstance)
    {
        GladiusLibHandle hInstance = nullptr;
        if (pInstance != nullptr) {
            hInstance = pInstance->GetHandle();
        };
        CheckError(nullptr,gladiuslib_releaseinstance(hInstance));
    }
    
    /**
    * CWrapper::CreateGladius - Creates a new Gladius instance
    * @return New Gladius instance
    */
    inline PGladius CWrapper::CreateGladius()
    {
        GladiusLibHandle hInstance = nullptr;
        CheckError(nullptr,gladiuslib_creategladius(&hInstance));
        
        if (!hInstance) {
            CheckError(nullptr,GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CGladius>(this, hInstance);
    }
    
    inline void CWrapper::CheckError(CBase * pBaseClass, GladiusLibResult nResult)
    {
        if (nResult != 0) {
            std::string sErrorMessage;
            if (pBaseClass != nullptr) {
                GetLastError(pBaseClass, sErrorMessage);
            }
            throw EGladiusLibException(nResult, sErrorMessage);
        }
    }
    

    
    /**
     * Method definitions for class CBase
     */
    
    /**
     * Method definitions for class CBoundingBox
     */
    
    /**
    * CBoundingBox::GetMin - Returns the minimum coordinates of the bounding box
    * @return The number of elements
    */
    sVector3f CBoundingBox::GetMin()
    {
        sVector3f resultMin;
        CheckError(gladiuslib_boundingbox_getmin(m_pHandle, &resultMin));
        
        return resultMin;
    }
    
    /**
    * CBoundingBox::GetMax - Returns the nmaximum coordinates of the bounding box
    * @return The number of elements
    */
    sVector3f CBoundingBox::GetMax()
    {
        sVector3f resultMax;
        CheckError(gladiuslib_boundingbox_getmax(m_pHandle, &resultMax));
        
        return resultMax;
    }
    
    /**
     * Method definitions for class CFace
     */
    
    /**
    * CFace::GetVertexA - Returns the vertex A of the face
    * @return Vertex of the face
    */
    sVector3f CFace::GetVertexA()
    {
        sVector3f resultVertexA;
        CheckError(gladiuslib_face_getvertexa(m_pHandle, &resultVertexA));
        
        return resultVertexA;
    }
    
    /**
    * CFace::GetVertexB - Returns the vertex B of the face
    * @return Vertex of the face
    */
    sVector3f CFace::GetVertexB()
    {
        sVector3f resultVertexB;
        CheckError(gladiuslib_face_getvertexb(m_pHandle, &resultVertexB));
        
        return resultVertexB;
    }
    
    /**
    * CFace::GetVertexC - Returns the vertex C of the face
    * @return Vertex of the face
    */
    sVector3f CFace::GetVertexC()
    {
        sVector3f resultVertexC;
        CheckError(gladiuslib_face_getvertexc(m_pHandle, &resultVertexC));
        
        return resultVertexC;
    }
    
    /**
    * CFace::GetNormal - Returns the normal of the face
    * @return Normal of the face
    */
    sVector3f CFace::GetNormal()
    {
        sVector3f resultNormal;
        CheckError(gladiuslib_face_getnormal(m_pHandle, &resultNormal));
        
        return resultNormal;
    }
    
    /**
    * CFace::GetNormalA - Returns the normal of vertex A
    * @return Normal of vertex A
    */
    sVector3f CFace::GetNormalA()
    {
        sVector3f resultNormal;
        CheckError(gladiuslib_face_getnormala(m_pHandle, &resultNormal));
        
        return resultNormal;
    }
    
    /**
    * CFace::GetNormalB - Returns the normal of vertex B
    * @return Normal of vertex B
    */
    sVector3f CFace::GetNormalB()
    {
        sVector3f resultNormal;
        CheckError(gladiuslib_face_getnormalb(m_pHandle, &resultNormal));
        
        return resultNormal;
    }
    
    /**
    * CFace::GetNormalC - Returns the normal of vertex C
    * @return Normal of vertex C
    */
    sVector3f CFace::GetNormalC()
    {
        sVector3f resultNormal;
        CheckError(gladiuslib_face_getnormalc(m_pHandle, &resultNormal));
        
        return resultNormal;
    }
    
    /**
     * Method definitions for class CDetailedErrorAccessor
     */
    
    /**
    * CDetailedErrorAccessor::GetSize - Returns the number of elements
    * @return The number of elements
    */
    GladiusLib_uint64 CDetailedErrorAccessor::GetSize()
    {
        GladiusLib_uint64 resultSize = 0;
        CheckError(gladiuslib_detailederroraccessor_getsize(m_pHandle, &resultSize));
        
        return resultSize;
    }
    
    /**
    * CDetailedErrorAccessor::Next - Go to the next element
    * @return Returns true, if there is a next element
    */
    bool CDetailedErrorAccessor::Next()
    {
        bool resultResult = 0;
        CheckError(gladiuslib_detailederroraccessor_next(m_pHandle, &resultResult));
        
        return resultResult;
    }
    
    /**
    * CDetailedErrorAccessor::Prev - Go to the previous element
    * @return Returns true, if there is a previous element
    */
    bool CDetailedErrorAccessor::Prev()
    {
        bool resultResult = 0;
        CheckError(gladiuslib_detailederroraccessor_prev(m_pHandle, &resultResult));
        
        return resultResult;
    }
    
    /**
    * CDetailedErrorAccessor::Begin - Go to the first element
    */
    void CDetailedErrorAccessor::Begin()
    {
        CheckError(gladiuslib_detailederroraccessor_begin(m_pHandle));
    }
    
    /**
    * CDetailedErrorAccessor::GetTitle - Returns the title of the error
    * @return Title of the error
    */
    std::string CDetailedErrorAccessor::GetTitle()
    {
        GladiusLib_uint32 bytesNeededTitle = 0;
        GladiusLib_uint32 bytesWrittenTitle = 0;
        CheckError(gladiuslib_detailederroraccessor_gettitle(m_pHandle, 0, &bytesNeededTitle, nullptr));
        std::vector<char> bufferTitle(bytesNeededTitle);
        CheckError(gladiuslib_detailederroraccessor_gettitle(m_pHandle, bytesNeededTitle, &bytesWrittenTitle, &bufferTitle[0]));
        
        return std::string(&bufferTitle[0]);
    }
    
    /**
    * CDetailedErrorAccessor::GetDescription - Returns the description of the error
    * @return Description of the error
    */
    std::string CDetailedErrorAccessor::GetDescription()
    {
        GladiusLib_uint32 bytesNeededDescription = 0;
        GladiusLib_uint32 bytesWrittenDescription = 0;
        CheckError(gladiuslib_detailederroraccessor_getdescription(m_pHandle, 0, &bytesNeededDescription, nullptr));
        std::vector<char> bufferDescription(bytesNeededDescription);
        CheckError(gladiuslib_detailederroraccessor_getdescription(m_pHandle, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
        
        return std::string(&bufferDescription[0]);
    }
    
    /**
    * CDetailedErrorAccessor::GetSeverity - Returns the severity of the error
    * @return Severity of the error
    */
    GladiusLib_uint32 CDetailedErrorAccessor::GetSeverity()
    {
        GladiusLib_uint32 resultSeverity = 0;
        CheckError(gladiuslib_detailederroraccessor_getseverity(m_pHandle, &resultSeverity));
        
        return resultSeverity;
    }
    
    /**
     * Method definitions for class CResourceAccessor
     */
    
    /**
    * CResourceAccessor::GetSize - Returns the number of elements
    * @return The number of elements
    */
    GladiusLib_uint64 CResourceAccessor::GetSize()
    {
        GladiusLib_uint64 resultSize = 0;
        CheckError(gladiuslib_resourceaccessor_getsize(m_pHandle, &resultSize));
        
        return resultSize;
    }
    
    /**
    * CResourceAccessor::Next - Go to the next element
    * @return Returns true, if there is a next element
    */
    bool CResourceAccessor::Next()
    {
        bool resultResult = 0;
        CheckError(gladiuslib_resourceaccessor_next(m_pHandle, &resultResult));
        
        return resultResult;
    }
    
    /**
    * CResourceAccessor::Prev - Go to the previous element
    * @return Returns true, if there is a previous element
    */
    bool CResourceAccessor::Prev()
    {
        bool resultResult = 0;
        CheckError(gladiuslib_resourceaccessor_prev(m_pHandle, &resultResult));
        
        return resultResult;
    }
    
    /**
    * CResourceAccessor::Begin - Go to the first element
    */
    void CResourceAccessor::Begin()
    {
        CheckError(gladiuslib_resourceaccessor_begin(m_pHandle));
    }
    
    /**
     * Method definitions for class CPolygonAccessor
     */
    
    /**
    * CPolygonAccessor::GetCurrentVertex - Returns the current vertex
    * @return Returns the current vertex
    */
    sVector2f CPolygonAccessor::GetCurrentVertex()
    {
        sVector2f resultVertex;
        CheckError(gladiuslib_polygonaccessor_getcurrentvertex(m_pHandle, &resultVertex));
        
        return resultVertex;
    }
    
    /**
    * CPolygonAccessor::GetArea - Returns the enclosed area
    * @return Enclosed area
    */
    GladiusLib_single CPolygonAccessor::GetArea()
    {
        GladiusLib_single resultArea = 0;
        CheckError(gladiuslib_polygonaccessor_getarea(m_pHandle, &resultArea));
        
        return resultArea;
    }
    
    /**
     * Method definitions for class CContourAccessor
     */
    
    /**
    * CContourAccessor::GetCurrentPolygon - Returns an Accessor for the current Polygon
    * @return Returns the current vertex
    */
    PPolygonAccessor CContourAccessor::GetCurrentPolygon()
    {
        GladiusLibHandle hVertex = nullptr;
        CheckError(gladiuslib_contouraccessor_getcurrentpolygon(m_pHandle, &hVertex));
        
        if (!hVertex) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CPolygonAccessor>(m_pWrapper, hVertex);
    }
    
    /**
     * Method definitions for class CFaceAccessor
     */
    
    /**
    * CFaceAccessor::GetCurrentFace - Returns an Accessor for the current Face
    * @return Returns the current vertex
    */
    PFace CFaceAccessor::GetCurrentFace()
    {
        GladiusLibHandle hFace = nullptr;
        CheckError(gladiuslib_faceaccessor_getcurrentface(m_pHandle, &hFace));
        
        if (!hFace) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CFace>(m_pWrapper, hFace);
    }
    
    /**
     * Method definitions for class CChannelAccessor
     */
    
    /**
    * CChannelAccessor::Evaluate - Generates the matrix, necessary to call the methods below
    * @param[in] fZ_mm - Z-height in mm
    * @param[in] fPixelWidth_mm - 
    * @param[in] fPixelHeight_mm - 
    */
    void CChannelAccessor::Evaluate(const GladiusLib_single fZ_mm, const GladiusLib_single fPixelWidth_mm, const GladiusLib_single fPixelHeight_mm)
    {
        CheckError(gladiuslib_channelaccessor_evaluate(m_pHandle, fZ_mm, fPixelWidth_mm, fPixelHeight_mm));
    }
    
    /**
    * CChannelAccessor::GetMetaInfo - Returns meta information to the matrix. Note: Evaluate has to be called before.
    * @return Returns the current meta information to the channel matrix
    */
    sChannelMetaInfo CChannelAccessor::GetMetaInfo()
    {
        sChannelMetaInfo resultMetaInfo;
        CheckError(gladiuslib_channelaccessor_getmetainfo(m_pHandle, &resultMetaInfo));
        
        return resultMetaInfo;
    }
    
    /**
    * CChannelAccessor::Copy - Copies the matrix to the target address provided by the client. It is the responsibility of the client to ensure, that enough memory is reserverd. The required size can be queried from ChannelMetaInfo. Note: Evaluate has to be called before.
    * @param[in] nTargetPtr - Target address to copy the matrix to.
    */
    void CChannelAccessor::Copy(const GladiusLib_int64 nTargetPtr)
    {
        CheckError(gladiuslib_channelaccessor_copy(m_pHandle, nTargetPtr));
    }
    
    /**
    * CChannelAccessor::GetName - Short name of the channel, also used as key for accessing the channel
    * @return Short name of the channel, also used as key for accessing the channel
    */
    std::string CChannelAccessor::GetName()
    {
        GladiusLib_uint32 bytesNeededName = 0;
        GladiusLib_uint32 bytesWrittenName = 0;
        CheckError(gladiuslib_channelaccessor_getname(m_pHandle, 0, &bytesNeededName, nullptr));
        std::vector<char> bufferName(bytesNeededName);
        CheckError(gladiuslib_channelaccessor_getname(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
        
        return std::string(&bufferName[0]);
    }
    
    /**
    * CChannelAccessor::SwitchToChannel - Switches to the channel with the given name
    * @param[in] sName - Name of the channel to switch to.
    * @return True, if successful
    */
    bool CChannelAccessor::SwitchToChannel(const std::string & sName)
    {
        bool resultResult = 0;
        CheckError(gladiuslib_channelaccessor_switchtochannel(m_pHandle, sName.c_str(), &resultResult));
        
        return resultResult;
    }
    
    /**
     * Method definitions for class CGladius
     */
    
    /**
    * CGladius::LoadAssembly - Loads an Assembly
    * @param[in] sFilename - The filename of the assembly
    */
    void CGladius::LoadAssembly(const std::string & sFilename)
    {
        CheckError(gladiuslib_gladius_loadassembly(m_pHandle, sFilename.c_str()));
    }
    
    /**
    * CGladius::ExportSTL - Exports the current assembly to an stl-file
    * @param[in] sFilename - The target filename
    */
    void CGladius::ExportSTL(const std::string & sFilename)
    {
        CheckError(gladiuslib_gladius_exportstl(m_pHandle, sFilename.c_str()));
    }
    
    /**
    * CGladius::GetFloatParameter - Returns the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @return Value of the parameter
    */
    GladiusLib_single CGladius::GetFloatParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName)
    {
        GladiusLib_single resultValue = 0;
        CheckError(gladiuslib_gladius_getfloatparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), &resultValue));
        
        return resultValue;
    }
    
    /**
    * CGladius::SetFloatParameter - Sets the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @param[in] fValue - Value of the parameter
    */
    void CGladius::SetFloatParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const GladiusLib_single fValue)
    {
        CheckError(gladiuslib_gladius_setfloatparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), fValue));
    }
    
    /**
    * CGladius::GetStringParameter - Returns the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @return Value of the parameter
    */
    std::string CGladius::GetStringParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName)
    {
        GladiusLib_uint32 bytesNeededValue = 0;
        GladiusLib_uint32 bytesWrittenValue = 0;
        CheckError(gladiuslib_gladius_getstringparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
        std::vector<char> bufferValue(bytesNeededValue);
        CheckError(gladiuslib_gladius_getstringparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
        
        return std::string(&bufferValue[0]);
    }
    
    /**
    * CGladius::SetStringParameter - Sets the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @param[in] sValue - Value of the parameter
    */
    void CGladius::SetStringParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const std::string & sValue)
    {
        CheckError(gladiuslib_gladius_setstringparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), sValue.c_str()));
    }
    
    /**
    * CGladius::GetVector3fParameter - Returns the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @return Value of the parameter
    */
    sVector3f CGladius::GetVector3fParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName)
    {
        sVector3f resultValue;
        CheckError(gladiuslib_gladius_getvector3fparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), &resultValue));
        
        return resultValue;
    }
    
    /**
    * CGladius::SetVector3fParameter - Sets the value of the given parameter
    * @param[in] sModelName - Name of the model the parameter belongs to
    * @param[in] sNodeName - Name of the node the parameter belongs to
    * @param[in] sParameterName - Name of the parameter
    * @param[in] fX - Value of the parameter
    * @param[in] fY - Value of the parameter
    * @param[in] fZ - Value of the parameter
    */
    void CGladius::SetVector3fParameter(const std::string & sModelName, const std::string & sNodeName, const std::string & sParameterName, const GladiusLib_single fX, const GladiusLib_single fY, const GladiusLib_single fZ)
    {
        CheckError(gladiuslib_gladius_setvector3fparameter(m_pHandle, sModelName.c_str(), sNodeName.c_str(), sParameterName.c_str(), fX, fY, fZ));
    }
    
    /**
    * CGladius::GenerateContour - Generates a contour in the xy-plane
    * @param[in] fZ - Z-height in mm
    * @param[in] fOffset - Offset from the part boundary in mm
    * @return Accessor for the generated contour
    */
    PContourAccessor CGladius::GenerateContour(const GladiusLib_single fZ, const GladiusLib_single fOffset)
    {
        GladiusLibHandle hAccessor = nullptr;
        CheckError(gladiuslib_gladius_generatecontour(m_pHandle, fZ, fOffset, &hAccessor));
        
        if (!hAccessor) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CContourAccessor>(m_pWrapper, hAccessor);
    }
    
    /**
    * CGladius::ComputeBoundingBox - Computes and returns the bounding box of the model
    * @return The computed bounding box
    */
    PBoundingBox CGladius::ComputeBoundingBox()
    {
        GladiusLibHandle hBoundingBox = nullptr;
        CheckError(gladiuslib_gladius_computeboundingbox(m_pHandle, &hBoundingBox));
        
        if (!hBoundingBox) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CBoundingBox>(m_pWrapper, hBoundingBox);
    }
    
    /**
    * CGladius::GeneratePreviewMesh - Computes a coarse mesh of the model that can be used for preview or collision detection
    * @return Accessor to the faces of the preview mesh
    */
    PFaceAccessor CGladius::GeneratePreviewMesh()
    {
        GladiusLibHandle hFaces = nullptr;
        CheckError(gladiuslib_gladius_generatepreviewmesh(m_pHandle, &hFaces));
        
        if (!hFaces) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CFaceAccessor>(m_pWrapper, hFaces);
    }
    
    /**
    * CGladius::GetChannels - Returns an accessor to all channels
    * @return Accessor to the the avilable channels
    */
    PChannelAccessor CGladius::GetChannels()
    {
        GladiusLibHandle hAccessor = nullptr;
        CheckError(gladiuslib_gladius_getchannels(m_pHandle, &hAccessor));
        
        if (!hAccessor) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CChannelAccessor>(m_pWrapper, hAccessor);
    }
    
    /**
    * CGladius::GetDetailedErrorAccessor - Returns an accessor to the detailed error information
    * @return Accessor to the detailed error information
    */
    PDetailedErrorAccessor CGladius::GetDetailedErrorAccessor()
    {
        GladiusLibHandle hAccessor = nullptr;
        CheckError(gladiuslib_gladius_getdetailederroraccessor(m_pHandle, &hAccessor));
        
        if (!hAccessor) {
            CheckError(GLADIUSLIB_ERROR_INVALIDPARAM);
        }
        return std::make_shared<CDetailedErrorAccessor>(m_pWrapper, hAccessor);
    }
    
    /**
    * CGladius::ClearDetailedErrors - Clears all detailed errors
    */
    void CGladius::ClearDetailedErrors()
    {
        CheckError(gladiuslib_gladius_cleardetailederrors(m_pHandle));
    }
    
    /**
    * CGladius::InjectSmoothingKernel - Injects a smoothing kernel into the model
    * @param[in] sKernel - Code of of the kernel to inject
    */
    void CGladius::InjectSmoothingKernel(const std::string & sKernel)
    {
        CheckError(gladiuslib_gladius_injectsmoothingkernel(m_pHandle, sKernel.c_str()));
    }

} // namespace GladiusLib

#endif // __GLADIUSLIB_CPPHEADER_IMPLICIT_CPP


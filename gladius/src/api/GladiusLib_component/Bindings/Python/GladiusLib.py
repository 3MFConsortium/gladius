'''++

Copyright (C) 2023 Jan Orend

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0.

Abstract: This is an autogenerated Python file in order to allow an easy
 use of GladiusLib

Interface version: 1.2.0

'''


import ctypes
import platform
import enum
import os

name = "gladius"

'''Definition of domain specific exception
'''
class EGladiusLibException(Exception):
	def __init__(self, code, message = ''):
		self._code = code
		self._message = message
	
	def __str__(self):
		if self._message:
			return 'GladiusLibException ' + str(self._code) + ': '+ str(self._message)
		return 'GladiusLibException ' + str(self._code)

'''Definition of binding API version
'''
class BindingVersion(enum.IntEnum):
	MAJOR = 1
	MINOR = 2
	MICRO = 0

'''Definition Error Codes
'''
class ErrorCodes(enum.IntEnum):
	SUCCESS = 0
	NOTIMPLEMENTED = 1
	INVALIDPARAM = 2
	INVALIDCAST = 3
	BUFFERTOOSMALL = 4
	GENERICEXCEPTION = 5
	COULDNOTLOADLIBRARY = 6
	COULDNOTFINDLIBRARYEXPORT = 7
	INCOMPATIBLEBINARYVERSION = 8

'''Definition of Function Table
'''
class FunctionTable:
	gladiuslib_getversion = None
	gladiuslib_getlasterror = None
	gladiuslib_acquireinstance = None
	gladiuslib_releaseinstance = None
	gladiuslib_creategladius = None
	gladiuslib_boundingbox_getmin = None
	gladiuslib_boundingbox_getmax = None
	gladiuslib_face_getvertexa = None
	gladiuslib_face_getvertexb = None
	gladiuslib_face_getvertexc = None
	gladiuslib_face_getnormal = None
	gladiuslib_face_getnormala = None
	gladiuslib_face_getnormalb = None
	gladiuslib_face_getnormalc = None
	gladiuslib_detailederroraccessor_getsize = None
	gladiuslib_detailederroraccessor_next = None
	gladiuslib_detailederroraccessor_prev = None
	gladiuslib_detailederroraccessor_begin = None
	gladiuslib_detailederroraccessor_gettitle = None
	gladiuslib_detailederroraccessor_getdescription = None
	gladiuslib_detailederroraccessor_getseverity = None
	gladiuslib_resourceaccessor_getsize = None
	gladiuslib_resourceaccessor_next = None
	gladiuslib_resourceaccessor_prev = None
	gladiuslib_resourceaccessor_begin = None
	gladiuslib_polygonaccessor_getcurrentvertex = None
	gladiuslib_polygonaccessor_getarea = None
	gladiuslib_contouraccessor_getcurrentpolygon = None
	gladiuslib_faceaccessor_getcurrentface = None
	gladiuslib_channelaccessor_evaluate = None
	gladiuslib_channelaccessor_getmetainfo = None
	gladiuslib_channelaccessor_copy = None
	gladiuslib_channelaccessor_getname = None
	gladiuslib_channelaccessor_switchtochannel = None
	gladiuslib_gladius_loadassembly = None
	gladiuslib_gladius_exportstl = None
	gladiuslib_gladius_getfloatparameter = None
	gladiuslib_gladius_setfloatparameter = None
	gladiuslib_gladius_getstringparameter = None
	gladiuslib_gladius_setstringparameter = None
	gladiuslib_gladius_getvector3fparameter = None
	gladiuslib_gladius_setvector3fparameter = None
	gladiuslib_gladius_generatecontour = None
	gladiuslib_gladius_computeboundingbox = None
	gladiuslib_gladius_generatepreviewmesh = None
	gladiuslib_gladius_getchannels = None
	gladiuslib_gladius_getdetailederroraccessor = None
	gladiuslib_gladius_cleardetailederrors = None
	gladiuslib_gladius_injectsmoothingkernel = None

'''Definition of Structs
'''
'''Definition of Vector2f
'''
class Vector2f(ctypes.Structure):
	_pack_ = 1
	_fields_ = [
		("Coordinates", ctypes.c_float * 2)
	]
'''Definition of Vector3f
'''
class Vector3f(ctypes.Structure):
	_pack_ = 1
	_fields_ = [
		("Coordinates", ctypes.c_float * 3)
	]
'''Definition of ChannelMetaInfo
'''
class ChannelMetaInfo(ctypes.Structure):
	_pack_ = 1
	_fields_ = [
		("MinPosition", ctypes.c_float * 2), 
		("MaxPosition", ctypes.c_float * 2), 
		("Size", ctypes.c_int32 * 2), 
		("RequiredMemory", ctypes.c_int32)
	]


'''Wrapper Class Implementation
'''
class Wrapper:

	def __init__(self, libraryName = None, symbolLookupMethodAddress = None):
		ending = ''
		if platform.system() == 'Windows':
			ending = 'dll'
		elif platform.system() == 'Linux':
			ending = 'so'
		elif platform.system() == 'Darwin':
			ending = 'dylib'
		else:
			raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY)
		
		if (not libraryName) and (not symbolLookupMethodAddress):
			libraryName = os.path.join(os.path.dirname(os.path.realpath(__file__)),'gladius')
		
		if libraryName is not None:
			path = libraryName + '.' + ending
			try:
				self.lib = ctypes.CDLL(path)
			except Exception as e:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(e) + '| "'+path + '"' )
			
			self._loadFunctionTable()
		elif symbolLookupMethodAddress is not None:
				self.lib = FunctionTable()
				self._loadFunctionTableFromMethod(symbolLookupMethodAddress)
		else:
			raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(e))
		
		self._checkBinaryVersion()
	
	def _loadFunctionTableFromMethod(self, symbolLookupMethodAddress):
		try:
			symbolLookupMethodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			symbolLookupMethod = symbolLookupMethodType(int(symbolLookupMethodAddress))
			
			methodAddress = ctypes.c_void_p()
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_getversion")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32))
			self.lib.gladiuslib_getversion = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_getlasterror")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_getlasterror = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_acquireinstance")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.gladiuslib_acquireinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_releaseinstance")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.gladiuslib_releaseinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_creategladius")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_creategladius = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_boundingbox_getmin")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_boundingbox_getmin = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_boundingbox_getmax")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_boundingbox_getmax = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getvertexa")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getvertexa = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getvertexb")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getvertexb = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getvertexc")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getvertexc = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getnormal")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getnormal = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getnormala")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getnormala = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getnormalb")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getnormalb = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_face_getnormalc")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_face_getnormalc = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_getsize")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64))
			self.lib.gladiuslib_detailederroraccessor_getsize = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_next")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_detailederroraccessor_next = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_prev")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_detailederroraccessor_prev = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_begin")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.gladiuslib_detailederroraccessor_begin = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_gettitle")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.gladiuslib_detailederroraccessor_gettitle = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_getdescription")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.gladiuslib_detailederroraccessor_getdescription = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_detailederroraccessor_getseverity")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32))
			self.lib.gladiuslib_detailederroraccessor_getseverity = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_resourceaccessor_getsize")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64))
			self.lib.gladiuslib_resourceaccessor_getsize = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_resourceaccessor_next")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_resourceaccessor_next = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_resourceaccessor_prev")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_resourceaccessor_prev = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_resourceaccessor_begin")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.gladiuslib_resourceaccessor_begin = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_polygonaccessor_getcurrentvertex")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(Vector2f))
			self.lib.gladiuslib_polygonaccessor_getcurrentvertex = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_polygonaccessor_getarea")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_float))
			self.lib.gladiuslib_polygonaccessor_getarea = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_contouraccessor_getcurrentpolygon")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_contouraccessor_getcurrentpolygon = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_faceaccessor_getcurrentface")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_faceaccessor_getcurrentface = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_channelaccessor_evaluate")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float)
			self.lib.gladiuslib_channelaccessor_evaluate = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_channelaccessor_getmetainfo")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ChannelMetaInfo))
			self.lib.gladiuslib_channelaccessor_getmetainfo = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_channelaccessor_copy")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_int64)
			self.lib.gladiuslib_channelaccessor_copy = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_channelaccessor_getname")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.gladiuslib_channelaccessor_getname = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_channelaccessor_switchtochannel")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.gladiuslib_channelaccessor_switchtochannel = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_loadassembly")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p)
			self.lib.gladiuslib_gladius_loadassembly = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_exportstl")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p)
			self.lib.gladiuslib_gladius_exportstl = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_getfloatparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_float))
			self.lib.gladiuslib_gladius_getfloatparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_setfloatparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float)
			self.lib.gladiuslib_gladius_setfloatparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_getstringparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.gladiuslib_gladius_getstringparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_setstringparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p)
			self.lib.gladiuslib_gladius_setstringparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_getvector3fparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(Vector3f))
			self.lib.gladiuslib_gladius_getvector3fparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_setvector3fparameter")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float, ctypes.c_float, ctypes.c_float)
			self.lib.gladiuslib_gladius_setvector3fparameter = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_generatecontour")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_gladius_generatecontour = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_computeboundingbox")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_gladius_computeboundingbox = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_generatepreviewmesh")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_gladius_generatepreviewmesh = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_getchannels")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_gladius_getchannels = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_getdetailederroraccessor")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.gladiuslib_gladius_getdetailederroraccessor = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_cleardetailederrors")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.gladiuslib_gladius_cleardetailederrors = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("gladiuslib_gladius_injectsmoothingkernel")), methodAddress)
			if err != 0:
				raise EGladiusLibException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p)
			self.lib.gladiuslib_gladius_injectsmoothingkernel = methodType(int(methodAddress.value))
			
		except AttributeError as ae:
			raise EGladiusLibException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
		
	def _loadFunctionTable(self):
		try:
			self.lib.gladiuslib_getversion.restype = ctypes.c_int32
			self.lib.gladiuslib_getversion.argtypes = [ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32)]
			
			self.lib.gladiuslib_getlasterror.restype = ctypes.c_int32
			self.lib.gladiuslib_getlasterror.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_acquireinstance.restype = ctypes.c_int32
			self.lib.gladiuslib_acquireinstance.argtypes = [ctypes.c_void_p]
			
			self.lib.gladiuslib_releaseinstance.restype = ctypes.c_int32
			self.lib.gladiuslib_releaseinstance.argtypes = [ctypes.c_void_p]
			
			self.lib.gladiuslib_creategladius.restype = ctypes.c_int32
			self.lib.gladiuslib_creategladius.argtypes = [ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_boundingbox_getmin.restype = ctypes.c_int32
			self.lib.gladiuslib_boundingbox_getmin.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_boundingbox_getmax.restype = ctypes.c_int32
			self.lib.gladiuslib_boundingbox_getmax.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getvertexa.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getvertexa.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getvertexb.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getvertexb.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getvertexc.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getvertexc.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getnormal.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getnormal.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getnormala.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getnormala.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getnormalb.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getnormalb.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_face_getnormalc.restype = ctypes.c_int32
			self.lib.gladiuslib_face_getnormalc.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_detailederroraccessor_getsize.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_getsize.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64)]
			
			self.lib.gladiuslib_detailederroraccessor_next.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_next.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_detailederroraccessor_prev.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_prev.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_detailederroraccessor_begin.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_begin.argtypes = [ctypes.c_void_p]
			
			self.lib.gladiuslib_detailederroraccessor_gettitle.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_gettitle.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.gladiuslib_detailederroraccessor_getdescription.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_getdescription.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.gladiuslib_detailederroraccessor_getseverity.restype = ctypes.c_int32
			self.lib.gladiuslib_detailederroraccessor_getseverity.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32)]
			
			self.lib.gladiuslib_resourceaccessor_getsize.restype = ctypes.c_int32
			self.lib.gladiuslib_resourceaccessor_getsize.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64)]
			
			self.lib.gladiuslib_resourceaccessor_next.restype = ctypes.c_int32
			self.lib.gladiuslib_resourceaccessor_next.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_resourceaccessor_prev.restype = ctypes.c_int32
			self.lib.gladiuslib_resourceaccessor_prev.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_resourceaccessor_begin.restype = ctypes.c_int32
			self.lib.gladiuslib_resourceaccessor_begin.argtypes = [ctypes.c_void_p]
			
			self.lib.gladiuslib_polygonaccessor_getcurrentvertex.restype = ctypes.c_int32
			self.lib.gladiuslib_polygonaccessor_getcurrentvertex.argtypes = [ctypes.c_void_p, ctypes.POINTER(Vector2f)]
			
			self.lib.gladiuslib_polygonaccessor_getarea.restype = ctypes.c_int32
			self.lib.gladiuslib_polygonaccessor_getarea.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_float)]
			
			self.lib.gladiuslib_contouraccessor_getcurrentpolygon.restype = ctypes.c_int32
			self.lib.gladiuslib_contouraccessor_getcurrentpolygon.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_faceaccessor_getcurrentface.restype = ctypes.c_int32
			self.lib.gladiuslib_faceaccessor_getcurrentface.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_channelaccessor_evaluate.restype = ctypes.c_int32
			self.lib.gladiuslib_channelaccessor_evaluate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
			
			self.lib.gladiuslib_channelaccessor_getmetainfo.restype = ctypes.c_int32
			self.lib.gladiuslib_channelaccessor_getmetainfo.argtypes = [ctypes.c_void_p, ctypes.POINTER(ChannelMetaInfo)]
			
			self.lib.gladiuslib_channelaccessor_copy.restype = ctypes.c_int32
			self.lib.gladiuslib_channelaccessor_copy.argtypes = [ctypes.c_void_p, ctypes.c_int64]
			
			self.lib.gladiuslib_channelaccessor_getname.restype = ctypes.c_int32
			self.lib.gladiuslib_channelaccessor_getname.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.gladiuslib_channelaccessor_switchtochannel.restype = ctypes.c_int32
			self.lib.gladiuslib_channelaccessor_switchtochannel.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.gladiuslib_gladius_loadassembly.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_loadassembly.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
			
			self.lib.gladiuslib_gladius_exportstl.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_exportstl.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
			
			self.lib.gladiuslib_gladius_getfloatparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_getfloatparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_float)]
			
			self.lib.gladiuslib_gladius_setfloatparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_setfloatparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float]
			
			self.lib.gladiuslib_gladius_getstringparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_getstringparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.gladiuslib_gladius_setstringparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_setstringparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
			
			self.lib.gladiuslib_gladius_getvector3fparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_getvector3fparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(Vector3f)]
			
			self.lib.gladiuslib_gladius_setvector3fparameter.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_setvector3fparameter.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
			
			self.lib.gladiuslib_gladius_generatecontour.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_generatecontour.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_gladius_computeboundingbox.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_computeboundingbox.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_gladius_generatepreviewmesh.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_generatepreviewmesh.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_gladius_getchannels.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_getchannels.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_gladius_getdetailederroraccessor.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_getdetailederroraccessor.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.gladiuslib_gladius_cleardetailederrors.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_cleardetailederrors.argtypes = [ctypes.c_void_p]
			
			self.lib.gladiuslib_gladius_injectsmoothingkernel.restype = ctypes.c_int32
			self.lib.gladiuslib_gladius_injectsmoothingkernel.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
			
		except AttributeError as ae:
			raise EGladiusLibException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
	
	def _checkBinaryVersion(self):
		nMajor, nMinor, _ = self.GetVersion()
		if (nMajor != BindingVersion.MAJOR) or (nMinor < BindingVersion.MINOR):
			raise EGladiusLibException(ErrorCodes.INCOMPATIBLEBINARYVERSION)
	
	def checkError(self, instance, errorCode):
		if errorCode != ErrorCodes.SUCCESS.value:
			if instance:
				if instance._wrapper != self:
					raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'invalid wrapper call')
			message,_ = self.GetLastError(instance)
			raise EGladiusLibException(errorCode, message)
	
	def GetVersion(self):
		pMajor = ctypes.c_uint32()
		pMinor = ctypes.c_uint32()
		pMicro = ctypes.c_uint32()
		self.checkError(None, self.lib.gladiuslib_getversion(pMajor, pMinor, pMicro))
		
		return pMajor.value, pMinor.value, pMicro.value
	
	def GetLastError(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		nErrorMessageBufferSize = ctypes.c_uint64(0)
		nErrorMessageNeededChars = ctypes.c_uint64(0)
		pErrorMessageBuffer = ctypes.c_char_p(None)
		pHasError = ctypes.c_bool()
		self.checkError(None, self.lib.gladiuslib_getlasterror(InstanceHandle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		nErrorMessageBufferSize = ctypes.c_uint64(nErrorMessageNeededChars.value)
		pErrorMessageBuffer = (ctypes.c_char * (nErrorMessageNeededChars.value))()
		self.checkError(None, self.lib.gladiuslib_getlasterror(InstanceHandle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		
		return pErrorMessageBuffer.value.decode(), pHasError.value
	
	def AcquireInstance(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		self.checkError(None, self.lib.gladiuslib_acquireinstance(InstanceHandle))
		
	
	def ReleaseInstance(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		self.checkError(None, self.lib.gladiuslib_releaseinstance(InstanceHandle))
		
	
	def CreateGladius(self):
		InstanceHandle = ctypes.c_void_p()
		self.checkError(None, self.lib.gladiuslib_creategladius(InstanceHandle))
		if InstanceHandle:
			InstanceObject = Gladius(InstanceHandle, self)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return InstanceObject
	


''' Class Implementation for Base
'''
class Base:
	def __init__(self, handle, wrapper):
		if not handle or not wrapper:
			raise EGladiusLibException(ErrorCodes.INVALIDPARAM)
		self._handle = handle
		self._wrapper = wrapper
	
	def __del__(self):
		self._wrapper.ReleaseInstance(self)


''' Class Implementation for BoundingBox
'''
class BoundingBox(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetMin(self):
		pMin = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_boundingbox_getmin(self._handle, pMin))
		
		return pMin
	
	def GetMax(self):
		pMax = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_boundingbox_getmax(self._handle, pMax))
		
		return pMax
	


''' Class Implementation for Face
'''
class Face(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetVertexA(self):
		pVertexA = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getvertexa(self._handle, pVertexA))
		
		return pVertexA
	
	def GetVertexB(self):
		pVertexB = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getvertexb(self._handle, pVertexB))
		
		return pVertexB
	
	def GetVertexC(self):
		pVertexC = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getvertexc(self._handle, pVertexC))
		
		return pVertexC
	
	def GetNormal(self):
		pNormal = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getnormal(self._handle, pNormal))
		
		return pNormal
	
	def GetNormalA(self):
		pNormal = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getnormala(self._handle, pNormal))
		
		return pNormal
	
	def GetNormalB(self):
		pNormal = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getnormalb(self._handle, pNormal))
		
		return pNormal
	
	def GetNormalC(self):
		pNormal = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_face_getnormalc(self._handle, pNormal))
		
		return pNormal
	


''' Class Implementation for DetailedErrorAccessor
'''
class DetailedErrorAccessor(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetSize(self):
		pSize = ctypes.c_uint64()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_getsize(self._handle, pSize))
		
		return pSize.value
	
	def Next(self):
		pResult = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_next(self._handle, pResult))
		
		return pResult.value
	
	def Prev(self):
		pResult = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_prev(self._handle, pResult))
		
		return pResult.value
	
	def Begin(self):
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_begin(self._handle))
		
	
	def GetTitle(self):
		nTitleBufferSize = ctypes.c_uint64(0)
		nTitleNeededChars = ctypes.c_uint64(0)
		pTitleBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_gettitle(self._handle, nTitleBufferSize, nTitleNeededChars, pTitleBuffer))
		nTitleBufferSize = ctypes.c_uint64(nTitleNeededChars.value)
		pTitleBuffer = (ctypes.c_char * (nTitleNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_gettitle(self._handle, nTitleBufferSize, nTitleNeededChars, pTitleBuffer))
		
		return pTitleBuffer.value.decode()
	
	def GetDescription(self):
		nDescriptionBufferSize = ctypes.c_uint64(0)
		nDescriptionNeededChars = ctypes.c_uint64(0)
		pDescriptionBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_getdescription(self._handle, nDescriptionBufferSize, nDescriptionNeededChars, pDescriptionBuffer))
		nDescriptionBufferSize = ctypes.c_uint64(nDescriptionNeededChars.value)
		pDescriptionBuffer = (ctypes.c_char * (nDescriptionNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_getdescription(self._handle, nDescriptionBufferSize, nDescriptionNeededChars, pDescriptionBuffer))
		
		return pDescriptionBuffer.value.decode()
	
	def GetSeverity(self):
		pSeverity = ctypes.c_uint32()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_detailederroraccessor_getseverity(self._handle, pSeverity))
		
		return pSeverity.value
	


''' Class Implementation for ResourceAccessor
'''
class ResourceAccessor(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetSize(self):
		pSize = ctypes.c_uint64()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_resourceaccessor_getsize(self._handle, pSize))
		
		return pSize.value
	
	def Next(self):
		pResult = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_resourceaccessor_next(self._handle, pResult))
		
		return pResult.value
	
	def Prev(self):
		pResult = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_resourceaccessor_prev(self._handle, pResult))
		
		return pResult.value
	
	def Begin(self):
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_resourceaccessor_begin(self._handle))
		
	


''' Class Implementation for PolygonAccessor
'''
class PolygonAccessor(ResourceAccessor):
	def __init__(self, handle, wrapper):
		ResourceAccessor.__init__(self, handle, wrapper)
	def GetCurrentVertex(self):
		pVertex = Vector2f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_polygonaccessor_getcurrentvertex(self._handle, pVertex))
		
		return pVertex
	
	def GetArea(self):
		pArea = ctypes.c_float()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_polygonaccessor_getarea(self._handle, pArea))
		
		return pArea.value
	


''' Class Implementation for ContourAccessor
'''
class ContourAccessor(ResourceAccessor):
	def __init__(self, handle, wrapper):
		ResourceAccessor.__init__(self, handle, wrapper)
	def GetCurrentPolygon(self):
		VertexHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_contouraccessor_getcurrentpolygon(self._handle, VertexHandle))
		if VertexHandle:
			VertexObject = PolygonAccessor(VertexHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return VertexObject
	


''' Class Implementation for FaceAccessor
'''
class FaceAccessor(ResourceAccessor):
	def __init__(self, handle, wrapper):
		ResourceAccessor.__init__(self, handle, wrapper)
	def GetCurrentFace(self):
		FaceHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_faceaccessor_getcurrentface(self._handle, FaceHandle))
		if FaceHandle:
			FaceObject = Face(FaceHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return FaceObject
	


''' Class Implementation for ChannelAccessor
'''
class ChannelAccessor(ResourceAccessor):
	def __init__(self, handle, wrapper):
		ResourceAccessor.__init__(self, handle, wrapper)
	def Evaluate(self, Z_mm, PixelWidth_mm, PixelHeight_mm):
		fZ_mm = ctypes.c_float(Z_mm)
		fPixelWidth_mm = ctypes.c_float(PixelWidth_mm)
		fPixelHeight_mm = ctypes.c_float(PixelHeight_mm)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_evaluate(self._handle, fZ_mm, fPixelWidth_mm, fPixelHeight_mm))
		
	
	def GetMetaInfo(self):
		pMetaInfo = ChannelMetaInfo()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_getmetainfo(self._handle, pMetaInfo))
		
		return pMetaInfo
	
	def Copy(self, TargetPtr):
		nTargetPtr = ctypes.c_int64(TargetPtr)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_copy(self._handle, nTargetPtr))
		
	
	def GetName(self):
		nNameBufferSize = ctypes.c_uint64(0)
		nNameNeededChars = ctypes.c_uint64(0)
		pNameBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_getname(self._handle, nNameBufferSize, nNameNeededChars, pNameBuffer))
		nNameBufferSize = ctypes.c_uint64(nNameNeededChars.value)
		pNameBuffer = (ctypes.c_char * (nNameNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_getname(self._handle, nNameBufferSize, nNameNeededChars, pNameBuffer))
		
		return pNameBuffer.value.decode()
	
	def SwitchToChannel(self, Name):
		pName = ctypes.c_char_p(str.encode(Name))
		pResult = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_channelaccessor_switchtochannel(self._handle, pName, pResult))
		
		return pResult.value
	


''' Class Implementation for Gladius
'''
class Gladius(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def LoadAssembly(self, Filename):
		pFilename = ctypes.c_char_p(str.encode(Filename))
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_loadassembly(self._handle, pFilename))
		
	
	def ExportSTL(self, Filename):
		pFilename = ctypes.c_char_p(str.encode(Filename))
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_exportstl(self._handle, pFilename))
		
	
	def GetFloatParameter(self, ModelName, NodeName, ParameterName):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		pValue = ctypes.c_float()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getfloatparameter(self._handle, pModelName, pNodeName, pParameterName, pValue))
		
		return pValue.value
	
	def SetFloatParameter(self, ModelName, NodeName, ParameterName, Value):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		fValue = ctypes.c_float(Value)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_setfloatparameter(self._handle, pModelName, pNodeName, pParameterName, fValue))
		
	
	def GetStringParameter(self, ModelName, NodeName, ParameterName):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		nValueBufferSize = ctypes.c_uint64(0)
		nValueNeededChars = ctypes.c_uint64(0)
		pValueBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getstringparameter(self._handle, pModelName, pNodeName, pParameterName, nValueBufferSize, nValueNeededChars, pValueBuffer))
		nValueBufferSize = ctypes.c_uint64(nValueNeededChars.value)
		pValueBuffer = (ctypes.c_char * (nValueNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getstringparameter(self._handle, pModelName, pNodeName, pParameterName, nValueBufferSize, nValueNeededChars, pValueBuffer))
		
		return pValueBuffer.value.decode()
	
	def SetStringParameter(self, ModelName, NodeName, ParameterName, Value):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		pValue = ctypes.c_char_p(str.encode(Value))
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_setstringparameter(self._handle, pModelName, pNodeName, pParameterName, pValue))
		
	
	def GetVector3fParameter(self, ModelName, NodeName, ParameterName):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		pValue = Vector3f()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getvector3fparameter(self._handle, pModelName, pNodeName, pParameterName, pValue))
		
		return pValue
	
	def SetVector3fParameter(self, ModelName, NodeName, ParameterName, X, Y, Z):
		pModelName = ctypes.c_char_p(str.encode(ModelName))
		pNodeName = ctypes.c_char_p(str.encode(NodeName))
		pParameterName = ctypes.c_char_p(str.encode(ParameterName))
		fX = ctypes.c_float(X)
		fY = ctypes.c_float(Y)
		fZ = ctypes.c_float(Z)
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_setvector3fparameter(self._handle, pModelName, pNodeName, pParameterName, fX, fY, fZ))
		
	
	def GenerateContour(self, Z, Offset):
		fZ = ctypes.c_float(Z)
		fOffset = ctypes.c_float(Offset)
		AccessorHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_generatecontour(self._handle, fZ, fOffset, AccessorHandle))
		if AccessorHandle:
			AccessorObject = ContourAccessor(AccessorHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return AccessorObject
	
	def ComputeBoundingBox(self):
		BoundingBoxHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_computeboundingbox(self._handle, BoundingBoxHandle))
		if BoundingBoxHandle:
			BoundingBoxObject = BoundingBox(BoundingBoxHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return BoundingBoxObject
	
	def GeneratePreviewMesh(self):
		FacesHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_generatepreviewmesh(self._handle, FacesHandle))
		if FacesHandle:
			FacesObject = FaceAccessor(FacesHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return FacesObject
	
	def GetChannels(self):
		AccessorHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getchannels(self._handle, AccessorHandle))
		if AccessorHandle:
			AccessorObject = ChannelAccessor(AccessorHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return AccessorObject
	
	def GetDetailedErrorAccessor(self):
		AccessorHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_getdetailederroraccessor(self._handle, AccessorHandle))
		if AccessorHandle:
			AccessorObject = DetailedErrorAccessor(AccessorHandle, self._wrapper)
		else:
			raise EGladiusLibException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return AccessorObject
	
	def ClearDetailedErrors(self):
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_cleardetailederrors(self._handle))
		
	
	def InjectSmoothingKernel(self, Kernel):
		pKernel = ctypes.c_char_p(str.encode(Kernel))
		self._wrapper.checkError(self, self._wrapper.lib.gladiuslib_gladius_injectsmoothingkernel(self._handle, pKernel))
		
	
		
